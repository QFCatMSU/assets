---
title: "04: Commits"
short: "04"
# special characters for highlighting code : «»
---

## Purpose

Git repositories are centered around the Git Commits.  In this lesson, we will develop an intuitive understanding of how Git Commits works.

## What is Git?

Functionally, Git is version control software; however, Git does not create versions of your project by taking snapshots or copies of your project. Instead what Git does is more analogous to writing a book about your project, where the Commits are the chapters in the book.

 

In order to use Git effectively, you need to understand how these chapters (Commits) act as version-control software. Using the analogy of a book, we are going to provide a conceptual understanding of how Git works.

 

[Note: **Git** is version-control software, **GitHub** is online storage.  So, GitHub is the online storage for the book created by Git -- and your computer is the local storage for the book.]{.note}

## What is a repository 

A Git repository is always attached to a project folder.  The "book" about the project, including all the Commits, is contained in the hidden ***.git*** folder inside your project folder. In many ways, the ***.git*** folder is the Git repository.

 

If this is an RStudio Project, then the Project Folder also:

1.  contains an ***\*.Rproj*** file

2.  is the ***Working Directory*** for your project

     

[Note: a project technically does not include the project folder itself, only what is inside the folder.  This means that you can name the Project Folder whatever you want.]{.note}

## Using Git is like writing a book

When you use Git on a project folder,[you are essentially writing a book about your project]{.hl}. The book does not contain everything inside your project folder -- you can be selective about what gets included in the book and when it gets included.

 

At the broad level, the book created by Git contains two things:

1.  An ***index***, which lists every file in the project that is mentioned in the book.

2.  ***Chapters*** that contain information about file changes --  these are the ***Commits***

     

[Note: for now we are treating the Project as linear (i.e., a book) -- later we will deal with branches and merges that add a non-linear aspect to the project. However, the concepts of index and chapters still apply.]{.note}

### The index

The index contains a list of every file mentioned in the book along with the chapters the files are mentioned in.

 

[Not every file in your project will be in the index]{.hl}. Generally speaking, the files not included in the index are the files that collaborators do not need.

 

Some reasons a project file will not be in this book is:

-   The file contains local information only (e.g., your RStudio Project settings, the R history file)

-   The file is data generated by executing a script (i.e., the person downloading your project can generate the data themselves)

-   The file is a test or temporary file

     

[Note: **.gitignore** contains a list of files that are not included in the book (i.e., the files that do not get indexed)]{.note}

### The chapters (Commits)

The Commits are the chapters of the book.  A Commit contains an introduction (the Commit Message) and[changes to the files]{.hl} in your project.

 

These changes in the chapters (Commits) include:

-   Files added to project -- the chapter will contain the file name and the content of the new file

-   Files removed from project

-   Files renamed -- the chapter will contain the old and new name of the file

-   Files modified (the most common) -- the chapter will contain the content that was changed in the file

     

[Remeber that folders in Git are part of the file name, so a folder name change in Git would be a file name change.]{.note}

 

[You do not have to include every file change in a project to a Commit]{.hl}. You might decide that changes to certain files are not ready to be committed yet (e.g., the changes are still in beta) -- and include the file changes in a later chapter.

## How the book acts as version control software

The big thing to understand about Git is that Git does not store files -- *Git stores changes to files* (in the .git folder).

 

So, if you create a file called ***cheese.r***, add a bunch of code to it, and ***Commit*** the file...

 

Git will:

1.  add ***cheese.r*** to the book ***index***

2.  put an entry in the ***chapter*** (i.e., Commit) that says ***cheese.r*** was created

3.  put the content of ***cheese.r*** in the chapter -- since this is the first entry for ***cheese.r,*** [the content of the whole script is written to the chapter]{.hl}

4.  add this chapter to the ***cheese.r*** link in the index

![Git adding a new file, cheese.r, and its content to a chapter (Commit)](images/GH-Commit-AddFile.jpg){#fig-addFile .fs}

 

Later on, you realize you made mistake on line **12**:

``` r
else if(cheeseAns == "M«eu»nster")
```

And change the line to:

``` r
else if(cheeseAns == "M«ue»nster")
```

and ***Commit*** the file to a new chapter...

 

Git will:

-   put an entry in the new chapter that says something to the effect of:

    -   ***cheese.r*** line **12** replaced with ***else if(cheeseAns == "Muenster")***

-   add this chapter to the ***cheese.r*** link in the index

     

The image below shows the line change by putting the deleted line 12 in red and the new line 12 in green

![Git writing the modification to cheese.r in a chapter (Commit)](images/GH-Commit-ModifyFile.jpg){#fig-modifyFile .fs}

[Note: Chapters (i.e., Commits) usually contain information about the changes to many files -- as we will see when we get to the RStudio example.]{.note}

### How Git creates "versions" of a file

The index for your book gives all the chapters that contain information about the file ***cheese.r***. With this information, Git can reconstruct the file ***cheese.r*** to any point in time when ***cheese.r*** was committed to a chapter. Git does this by reading all the chapters that contain information about ***cheese.r*** up until the chapter that reflects the point in time you want ***cheese.r*** restored to.

 

Git works great for text files (e.g., scripts) as text files tend to be small and changes to scripts tend to be iterative; however, Git does not work well with media files (e.g., images, videos). [Extension: Why Git is bad for media files]

### How Git creates "versions" of your project

A single chapter (i.e., Commit) does not contain enough information to recreate your project.  However, reading the book up until and through the chapter does have the necessary information to recreate your project.

 

In other words, if you want to restore your project to the 15th chapter (i.e., 15th Commit) then Git will read the whole book up until chapter 15.  Git will reconstruct all the files that existed in your project in those chapters using the information in those chapters. The result is a project that is in the same state as the project in chapter 15.

 

[Note: Actually, Git reads the book backwards. In other words, Git starts with the newest chapter and undoes changes as it read the chapters in reverse order. This just happens to be more computationally efficient and is a subtle detail that will not affect anything until you get really advanced with Git.]{.note}

## Staging and Commits in RStudio

You do not have to Commit every file change.  You can keep some of your file changes local-only permanently (i.e., never Commit the file) or temporarily (i.e., add the file changes to a future Commit).

 

[note: If you have a file that you know you never want to Commit, then you should put the file in ***.gitignore***]{.note}

 

The process of choosing which files changes get added to the next Commit is called *Staging*.  Staging is done in the *Staging Area*, which is the place that lists all the file changes that have never been Committed.

 

In the second example I will Commit one change to the RStudio Project using Git:

-   ***test1.r*** renamed to ***test4.r***

### The Staging Area

All uncommitted file changes (i.e., changes not written to a chapter yet) to files not in .***gitignore*** will appear in the ***Staging Area***. The Staging Area lists all uncommitted changes to your project files and is located in two places in RStudio:

-   The ***Git*** tab

-   The ***Review Changes*** window after you click ***Commit*** in the ***Git*** tab

 

These two Staging Areas are the same. You can work from either one  -- changes to one are reflected in the other.

 

This Staging Area shows two files:

-   ***test2.r*** was edited (i.e.,  it was previously Committed and recently modified)

-   ***test3.r*** was created (i.e., it has never been Committed)

     

![The duplicate Staging Areas above both reflect the fact that there are two files with uncommitted changes: test2.r and test3.r](images/GH-StagingArea.jpg){#fig-stagingAreas .fs}

### File codes

Every file in the Staging Area will have a code next to it that gives its status.  The most common codes are:

-   **A** (green): file has been added

-   **D** (red): file has been deleted

-   **M** (blue): file has been modified

-   **R** (purple): file has been renamed

-   **?** (yellow): unknown because file has never been indexed (i.e., it is a new file) or is in a conflict state (we will deal with this in a later lesson)

### Pre-staged and staged codes (right/left-side)

The files listed in the Staging Area have changes not reflected in the repository (i.e., the book). Checking the file means you are going to include it in this Commit (i.e., chapter).  This is called ***Staging***.  You do not have to Stage every file change (i.e., you do not have to check every file).

 

For each file in the Staging Area, there are two sets of codes:

-   one on the right-side -- this is Git's best guess for the status of the pre-staged file

-   one on the left -- this is the status of the staged file

     

The **?** is the only code to appear on both sides at once (this is something I find confusing).  However, once the file is checked (i.e., the file is staged), the **?** will change to one of the other codes. 

### Staging Example 1: A modified file and an added file

In @fig-staging, Git shows that ***test2.r*** has been modified and ***test3.r*** is unknown; however, checking the files (i.e., ***Staging***) changes the status of ***test3.r*** to a green A (added).  The status of ***test2.r*** remains the same after checking.

![Checking the files Stages them for the next Commit (i.e., chapter)](images/GH-Staging.png){#fig-staging .fs}

The reason that ***test3.r*** initially had a status of **unknown**, is that the file did not exist in the index of the book (because it is a new file).  So, Git is not sure of the exact status of the file until it is Staged.  In the next example, we will see a file go from **unknown** to **renamed**.

 

If you ***Commit*** the changes to both files then they will both disappear from the Staging Area. If you Commit the changes to only one file then the other file will remain in the Staging Area -- and you can Commit it later.

### Staging example 2: Renaming a file

For this example, I renamed ***test1.r*** to ***test4.r***. In the Staging Area, Git labels ***test1.r*** as ***deleted*** and ***test4.r*** as ***unknown***.

![The Staging Area after test1.r was renamed test4.r](images/GH-StageRename-01.jpg){#fig-renameFile .fs}

If you stage both files, Git will realize that the two changes were really only one change -- a renamed file:

![After Staging the changes, Git changes the status to one file that has been renamed](images/GH-RenameStage.png){#fig-staging-rename .fs}

[The **renamed** status only applies when the file names changes and the file content stays the same]{.hl}*.* If you edit ***test4.r*** in any way before Staging then Git will think that you deleted ***test1.r*** and added a new file called ***test4.r***.

### The uncommitted files

Just a reminder that the file ***.gitignore*** contains an editable list of files that do not get committed (i.e., these files never get indexed in the book).

 

A ***.gitignore*** file:

``` r
.Rproj.user
.Rhistory
.RData
.Ruserdata
~*
doNotSync/
*.o
test1/*.jpg
test2/data/weatherData.csv
```

The top four files are added by RStudio because they only have meaning to the local user.  The others I have added: 

-   ***\****: file names that start with ( **\~** ), these are temporary files

-   ***doNotCommit/***:  Everything in the folder ***doNotCommit*** -- not necessary but it helps me to have this folder

-   all files will extension ***.o***

-   all ***.jpg*** files inside the ***test1*** folder

-   the ***weatherData.csv*** file inside the ***test2/data*** folder

 

[Extension: Ignoring a Committed file]

## Pushing Commits to GitHub

Just as a reminder -- when you create a Commit (i.e., a chapter in the book), [the Commit exists only on your computer]{.hl}.  To send the new Commits to GitHub (and, hence, the outside world), you need to ***Push*** the Commits by clicking the green up arrow. 

## Folder paths and Git

If you move a file to a new folder in your project then Git will also see this as a file being ***renamed*** (assuming you did not edit the file's content).  This is because Git sees the folder path as part of the file name.

 

As reflected in the Staging Areas above, Git does not see files named ***test1.r***, ***test2.r***, etc... [Git sees file paths]{.hl} named ***scripts/test1.r***, ***scripts/test2.r***, etc...  From Git's perspective, moving a file to a new folder just changes the path name, hence the file gets the renamed status.

 

So if you create a new folder called ***oldScripts*** and move ***test1.r*** to that folder then Git sees a file that has been renamed:

***scripts/test1.r  -\>  oldScripts/test1.r***

 

Or, if you create a folder within ***scripts*** called ***oldStuff*** and move ***test2.r*** to that folder then Git sees this renamed situation:

***scripts/test2.r  -\>  scripts/oldStuff/test2.r***

 

Lastly, you can rename the file and move it to a new folder and Git will still see it as a renamed situation:

***scripts/test3.r  -\>  oldscripts/2021/January/oldTest3.r***

...as long as the content of ***oldTest3.r*** and ***test3.r*** are the same

## Application

A\) Create 4 new Commits in your RStudio Project:

1.  A Commits where four files are added to your ***scripts*** folder: ***test1.r***, ***test2.r***, ***test3.r***, and ***test4.r***

    -   make sure each file has content but the content does not matter (e.g., it does not have to be a working script)

2.  A Commit where the content in ***test2.r*** and ***test4.r*** is modified

3.  A Commit where ***test3.r*** is deleted

4.  A Commit where ***test1.r*** is renamed to ***test5.r*** and moved to the folder ***scripts/oldStuff***

     

B\) Make sure you put an informative ***Commit Message*** for each Commit!

 

C\) Create an Issue in GitHub and add ***belinskyc*** as an assignee (@fig-github_issue). In the issue text say that you have completed the application.  This will only work if you have already added ***belinskyc*** as a collaborator and ***belinskyc*** accepted.

![Creating an Issue in GitHub and adding an assignee](images/GitHub_Issue.png){#fig-github_issue .fs}

## Extension: Why Git is bad for media files

Git does not store files, instead it stores the changes to the files. Script files are not very big to begin with...often measuring kilobytes in size. When you make changes to a script file, you are often just changing a few lines -- so, the changes often measure less than one kilobyte in size.

 

Media (e.g., images and videos), on the other hand, is much larger than script files and when you change the media, you are effectively rewriting the whole file. So, if you are using Git to write the media changes to a chapter (i.e., Commit), then each time there is a change you are essentially rewriting the whole media file to the chapter.  In other words, each time you are adding an entry to a chapter that is the size of the media file.

## Extension: Ignoring a Committed file

Git will not ignore a file in ***.gitignore*** if the file has already been indexed (i.e., was added to a previous Commit/Chapter). If you want to remove a file from your book, then you need to use the ***Terminal*** tab.

``` {.bash tab="Terminal"}
git rm "data/doNotWantThis.R" -f
```

This command deletes the file from the index.  This means future changes to the file will be ignored if the file is in ***.gitignore***.

 

However, there are still references to the file in the previous Commits and the file could be reconstructed by a collaborator.  If you want to remove all references to the file (e..g, the file contain sensitive information) then you have to do something like this:

<https://stackoverflow.com/questions/43762338/how-to-remove-file-from-git-history>
